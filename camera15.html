<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />
  <script src="matter.min.js"></script>
  <script>
    const { Engine, Render, Bodies, Composite, Runner, Body, World } = Matter;
    window.addEventListener("DOMContentLoaded", function () {
      matter_init();
      Matter.Events.on(engine, "afterUpdate", function () {
        sound();
        if (ball.position.x < R || ball.position.x > size - R) { Body.setVelocity(ball, { x: -ball.velocity.x / 2, y: ball.velocity.y }); }
        if (ball.position.y < R || ball.position.y > size - R) { Body.setVelocity(ball, { x: ball.velocity.x, y: -ball.velocity.y / 2 }); }
        Body.setPosition(ball, { x: clampNumber(ball.position.x, R, size - R), y: clampNumber(ball.position.y, R, size - R) });
        if (distance(ball.position, goal.position) < (R + goalR)) {
          score++; document.getElementById("score").innerText = "score:" + score;
          var posx;
          while (true) {
            posx = Math.random() * (size - R / 2) + goalR;
            if (Math.abs(posx - ball.position.x) > goalR + R) break;
          }
          Body.setPosition(goal, { x: posx, y: (Math.random() * size / 2 + R) });
          Body.setVelocity(ball, { x: 0, y: 0 });
        }
      });
    }); let radix = 1.5, index = 15, size = 640, blank = 10, R = 64, goalR = R / 2, barWid = 32, score = 0;
    let analyser, freq, min, max, stream;
    var bar = Array(index), barView = Array(index);
    const constraint = Array(index);
    let ball, goal;
    var engine;
    async function matter_init() {
      engine = Engine.create();
      //engine.gravity.scale = 0.0018;
      var render = Render.create({
        element: document.getElementById("canvas"),
        engine: engine,
        options: {
          width: size,
          height: size,
          wireframes: false
        }
      });
      ball = Bodies.circle(size / 2, size / 2, R, {
        friction: 0, frictionAir: 0, restitution: 0.5, render: {
          fillStyle: '#ffffff',
        }
      });
      goal = Bodies.circle(500, 300, goalR, {
        friction: 0, frictionAir: 0, restitution: 0.5, isStatic: true, render: {
          fillStyle: '#770000', options: {
            wireframes: false
          },
          collisionFilter: -1
        }
      });
      Composite.add(engine.world, [ball, goal]);
      Render.run(render);
      // create runner
      var runner = Runner.create();

      // run the engine
      Runner.run(runner, engine);

      // マイク許可
      stream = await navigator.mediaDevices.getUserMedia({ audio: true, autoGainControl: true });
      for (var i = 0; i < index; i++) {
        bar[i] = Bodies.rectangle(i * (size - blank) / index + barWid / 2 + blank, size * 1.5, barWid, size, {
          isStatic: true,
          chamfer: { radius: barWid / 2 }
        });
        barView[i] = Bodies.rectangle(bar[i].position.x, bar[i].position.y, barWid, size, {
          isStatic: true,
          render: {
            fillStyle: '#ffffff',
          }, collisionFilter: -1
        });
      }
      Composite.add(engine.world, bar);
      Composite.add(engine.world, barView);
      // AudioContext 作成
      const audioCtx = new AudioContext();
      // マイク → AudioNode
      const source = audioCtx.createMediaStreamSource(stream);
      analyser = audioCtx.createAnalyser();
      analyser.fftSize = 32768;

      source.connect(analyser);

      freq = new Uint8Array(analyser.frequencyBinCount);//110より小さく880より大きく
      min = Math.floor(110 / (audioCtx.sampleRate / analyser.fftSize));
      max = Math.ceil(880 / (audioCtx.sampleRate / analyser.fftSize)) + 1;
    }
    //let tempMax = 0;
    //let soundLog = Array(index).fill(0);
    async function sound() {
      if (!stream) return;
      analyser.getByteFrequencyData(freq);
      var left = 0;
      for (var i = 1; i <= index; i++) {
        var right = Math.ceil((radix ** i) * (max - min + 1) / (radix ** index)) - 1;//1からなので範囲が1小さくなる
        var num = freq.slice(left + min, right + min);
        var sum = (num.reduce((currentTotal, num) => currentTotal + num, 0));
        average = sum / num.length;
        //Body.translate(bar[i - 1], { x: 0, y: soundLog[i - 1] - average }, [updateVelocity = false])
        Body.setPosition(bar[i - 1], { x: bar[i - 1].position.x, y: size * 1.5 - average }, [updateVelocity = true]);
        Body.setPosition(barView[i - 1], { x: bar[i - 1].position.x, y: bar[i - 1].position.y });

        left = right;
        //soundLog[i - 1] = average;
      }


    }
    function clampNumber(num, a, b) {
      return Math.max(Math.min(num, Math.max(a, b)), Math.min(a, b));
    }
    function distance(pos1, pos2) {
      return Math.sqrt((pos1.x - pos2.x) ** 2 + (pos1.y - pos2.y) ** 2);
    }
  </script>
  <style>
    body {
      font-size: x-large;
      text-align: center;
    }

    canvas {
      width: min(100%, 88vh);
    }
  </style>
</head>

<div id="canvas">
</div>
<p id="score">score:0</p>

</html>
